<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · DynamicQuantities.jl</title><meta name="title" content="Examples · DynamicQuantities.jl"/><meta property="og:title" content="Examples · DynamicQuantities.jl"/><meta property="twitter:title" content="Examples · DynamicQuantities.jl"/><meta name="description" content="Documentation for DynamicQuantities.jl."/><meta property="og:description" content="Documentation for DynamicQuantities.jl."/><meta property="twitter:description" content="Documentation for DynamicQuantities.jl."/><meta property="og:url" content="https://ai.damtp.cam.ac.uk/dynamicquantities/stable/examples/"/><meta property="twitter:url" content="https://ai.damtp.cam.ac.uk/dynamicquantities/stable/examples/"/><link rel="canonical" href="https://ai.damtp.cam.ac.uk/dynamicquantities/stable/examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DynamicQuantities.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#1.-Solving-a-Chemistry-Homework-Problem"><span>1. Solving a Chemistry Homework Problem</span></a></li><li><a class="tocitem" href="#2.-Projectile-motion"><span>2. Projectile motion</span></a></li><li><a class="tocitem" href="#3.-Using-dimensional-angles"><span>3. Using dimensional angles</span></a></li><li><a class="tocitem" href="#4.-Assorted-examples"><span>4. Assorted examples</span></a></li></ul></li><li><a class="tocitem" href="../api/">Utilities</a></li><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../constants/">Constants</a></li><li><a class="tocitem" href="../symbolic_units/">Symbolic Units</a></li><li><a class="tocitem" href="../types/">Types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SymbolicML/DynamicQuantities.jl/blob/main/docs/src/examples.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Toy-Examples-with-Code"><a class="docs-heading-anchor" href="#Toy-Examples-with-Code">Toy Examples with Code</a><a id="Toy-Examples-with-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Toy-Examples-with-Code" title="Permalink"></a></h1><h2 id="1.-Solving-a-Chemistry-Homework-Problem"><a class="docs-heading-anchor" href="#1.-Solving-a-Chemistry-Homework-Problem">1. Solving a Chemistry Homework Problem</a><a id="1.-Solving-a-Chemistry-Homework-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Solving-a-Chemistry-Homework-Problem" title="Permalink"></a></h2><p>On your chemistry homework, you are faced with the following problem on the photoelectric effect<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>:</p><blockquote><p>In a photoelectric effect experiment, electrons are ejected from a titanium surface (work function <span>$\Phi = 4.33\mathrm{eV}$</span>) following irradition with UV light. The energy of the incident UV light is <span>$7.2 \cdot 10^{-19} \mathrm{J}$</span> per photon. Calculate the wavelength of the ejected electrons, in nanometers.</p></blockquote><p>Let&#39;s solve this problem with <code>DynamicQuantities.jl</code>!</p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicQuantities

julia&gt; using DynamicQuantities.Constants: h, m_e

julia&gt; Φ = 4.33u&quot;Constants.eV&quot; # work function
6.93742482522e-19 m² kg s⁻²

julia&gt; E = 7.2e-19u&quot;J&quot; # incident energy
7.2e-19 m² kg s⁻²

julia&gt; p = sqrt(2 * m_e * (E - Φ)) # momentum of ejected electrons
2.1871890716439906e-25 m kg s⁻¹

julia&gt; λ = h / p # wavelength of ejected electrons
3.029491247878056e-9 m

julia&gt; λ |&gt; us&quot;nm&quot; # return answer in nanometers (equivalent to `uconvert(us&quot;nm&quot;, λ)`)
3.0294912478780556 nm</code></pre><p>Since units are automatically propagated, we can verify the dimension of our answer and all intermediates. Also, using <code>DynamicQuantities.Constants</code>, we were able to obtain the (dimensionful!) values of all necessary constants without typing them ourselves.</p><h2 id="2.-Projectile-motion"><a class="docs-heading-anchor" href="#2.-Projectile-motion">2. Projectile motion</a><a id="2.-Projectile-motion-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Projectile-motion" title="Permalink"></a></h2><p>Let&#39;s solve a simple projectile motion problem. First load the <code>DynamicQuantities</code> module:</p><pre><code class="language-julia hljs">using DynamicQuantities</code></pre><p>Set up initial conditions as quantities:</p><pre><code class="language-julia hljs"># Can explicitly import units:
using DynamicQuantities: km, m, s, min

y0 = 10km
v0 = 250m/s
θ = deg2rad(60)
g = 9.81m/s^2</code></pre><p>Next, we use trig functions to calculate x and y components of initial velocity. <code>vx0</code> is the x component and <code>vy0</code> is the y component:</p><pre><code class="language-julia hljs">vx0 = v0 * cos(θ)
vy0 = v0 * sin(θ)</code></pre><p>Next, let&#39;s create a time vector from 0 seconds to 1.3 minutes. Note that these are the same dimension (time), so it&#39;s fine to treat them as dimensionally equivalent!</p><pre><code class="language-julia hljs">t = range(0s, 1.3min, length=100)</code></pre><p>Next, use kinematic equations to calculate x and y as a function of time. <code>x(t)</code> is the x position at time t, and <code>y(t)</code> is the y position:</p><pre><code class="language-julia hljs">x(t) = vx0*t
y(t) = vy0*t - 0.5*g*t^2 + y0</code></pre><p>These are functions, so let&#39;s evaluate them:</p><pre><code class="language-julia hljs">x_si = x.(t)
y_si = y.(t)</code></pre><p>These are regular vectors of quantities with <code>Dimensions</code> for physical dimensions.</p><p>Next, let&#39;s plot the trajectory. First convert to km and strip units:</p><pre><code class="language-julia hljs">x_km = ustrip.(x_si .|&gt; us&quot;km&quot;)
y_km = ustrip.(y_si .|&gt; us&quot;km&quot;)</code></pre><p>Now, we plot:</p><pre><code class="language-julia hljs">plot(x_km, y_km, label=&quot;Trajectory&quot;, xlabel=&quot;x [km]&quot;, ylabel=&quot;y [km]&quot;)</code></pre><h2 id="3.-Using-dimensional-angles"><a class="docs-heading-anchor" href="#3.-Using-dimensional-angles">3. Using dimensional angles</a><a id="3.-Using-dimensional-angles-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Using-dimensional-angles" title="Permalink"></a></h2><p>Say that we wish to track angles as a unit, rather than assume the SI convention that <code>1 rad = 1</code>. We can do this by creating a new struct to track dimensions:</p><pre><code class="language-julia hljs">using DynamicQuantities

struct AngleDimensions{R} &lt;: AbstractDimensions{R}
    length::R
    mass::R
    time::R
    current::R
    temperature::R
    luminosity::R
    amount::R
    angle::R
end</code></pre><p>Simply by inheriting from <code>AbstractDimensions</code>, we get all the constructors and operations as defined on <code>Dimensions</code>:</p><pre><code class="language-julia hljs">julia&gt; x = Quantity(1.0, AngleDimensions(length=1, angle=-1))
1.0 m angle⁻¹</code></pre><p>However, perhaps we want to set the default <code>angle</code> dimension as <code>rad</code>. We can do this by defining a method for <code>dimension_name</code>:</p><pre><code class="language-julia hljs">import DynamicQuantities: DynamicQuantities as DQ

function DQ.dimension_name(::AngleDimensions, k::Symbol)
    default_dimensions = (
        length = &quot;m&quot;,
        mass = &quot;kg&quot;,
        time = &quot;s&quot;,
        current = &quot;A&quot;,
        temperature = &quot;K&quot;,
        luminosity = &quot;cd&quot;,
        amount = &quot;mol&quot;,
        angle = &quot;rad&quot;,
    )
    return get(default_dimensions, k, string(k))
end</code></pre><p>This gives us the following behavior:</p><pre><code class="language-julia hljs">julia&gt; x = Quantity(1.0, AngleDimensions(length=1, angle=-1))
1.0 m rad⁻¹</code></pre><p>Next, say that we are working with existing quantities defined using standard <code>Dimensions</code>. We want to promote these to our new <code>AngleDimensions</code> type.</p><p>For this, we define two functions: <code>promote_rule</code> and a constructor for <code>AngleDimensions</code> from regular <code>Dimensions</code>:</p><pre><code class="language-julia hljs">function Base.promote_rule(::Type{AngleDimensions{R1}}, ::Type{Dimensions{R2}}) where {R1,R2}
    return AngleDimensions{promote_type(R1, R2)}
end
function Base.convert(::Type{Quantity{T,AngleDimensions{R}}}, q::Quantity{&lt;:Any,&lt;:Dimensions}) where {T,Din,R}
    val = ustrip(q)
    d = dimension(q)
    return Quantity(
        T(val),
        AngleDimensions{R}(;
            d.length, d.mass, d.time, d.current, d.temperature, d.luminosity, d.amount, angle=zero(R)
        )
    )
end</code></pre><p>This means that whenever a <code>Quantity{&lt;:Any,&lt;:Dimensions}</code> interacts with a <code>Quantity{&lt;:Any,&lt;:AngleDimensions}</code>, the result will be a <code>Quantity{&lt;:Any,&lt;:AngleDimensions}</code>, and we will initialize the angle dimension to 0. (Code not given for <code>SymbolicDimensions</code>; you will probably want to treat the angles in symbolic units explicitly, so that <code>us&quot;rad&quot;</code> is correctly tracked.)</p><p>Let&#39;s define a constant for <code>rad</code>:</p><pre><code class="language-julia hljs">julia&gt; const rad = Quantity(1.0, AngleDimensions(angle = 1))
1.0 rad</code></pre><p>and use it in a calculation:</p><pre><code class="language-julia hljs">julia&gt; x = 2rad
2.0 rad

julia&gt; y = 10u&quot;min&quot;
600.0 s

julia&gt; angular_velocity = x / y
0.0033333333333333335 s⁻¹ rad</code></pre><p>which as we can see, automatically promotes to <code>AngleDimensions</code>.</p><p><strong>However, note the following:</strong> If existing code uses <code>rad</code> as a unit without tracking it with <code>AngleDimensions</code>, you will need to explicitly add the missing dimensions. For this reason, if you decide to take this approach to tracking units, you probably want to use <code>AngleDimensions</code> throughout your codebase, rather than mixing them.</p><h2 id="4.-Assorted-examples"><a class="docs-heading-anchor" href="#4.-Assorted-examples">4. Assorted examples</a><a id="4.-Assorted-examples-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Assorted-examples" title="Permalink"></a></h2><p>This section demonstrates miscellaneous examples of using <code>DynamicQuantities.jl</code>.</p><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>Convert a quantity to have a new type for the value:</p><pre><code class="language-julia hljs">quantity = 1.5u&quot;m&quot;

convert_q = Quantity{Float32}(quantity)

println(&quot;Converted Quantity to Float32: &quot;, convert_q)</code></pre><h3 id="Array-basics"><a class="docs-heading-anchor" href="#Array-basics">Array basics</a><a id="Array-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Array-basics" title="Permalink"></a></h3><p>Create a <code>QuantityArray</code> (an array of quantities with the same dimension) by passing an array and a single quantity:</p><pre><code class="language-julia hljs">x = QuantityArray(randn(32), u&quot;km/s&quot;)</code></pre><p>or, by passing an array of individual quantities:</p><pre><code class="language-julia hljs">y = randn(32)
y_q = QuantityArray(y .* u&quot;m * cd / s&quot;)</code></pre><p>We can take advantage of this being <code>&lt;:AbstractArray</code>:</p><pre><code class="language-julia hljs">println(&quot;Sum x: &quot;, sum(x))</code></pre><p>We can also do things like setting a particular element:</p><pre><code class="language-julia hljs">y_q[5] = Quantity(5, length=1, luminosity=1, time=-1)
println(&quot;5th element of y_q: &quot;, y_q[5])</code></pre><p>We can get back the original array with <code>ustrip</code>:</p><pre><code class="language-julia hljs">println(&quot;Stripped y_q: &quot;, ustrip(y_q))</code></pre><p>This <code>QuantityArray</code> is useful for broadcasting:</p><pre><code class="language-julia hljs">f_square(v) = v^2 * 1.5 - v^2
println(&quot;Applying function to y_q: &quot;, sum(f_square.(y_q)))</code></pre><h3 id="Fill"><a class="docs-heading-anchor" href="#Fill">Fill</a><a id="Fill-1"></a><a class="docs-heading-anchor-permalink" href="#Fill" title="Permalink"></a></h3><p>We can also make <code>QuantityArray</code> using <code>fill</code>:</p><pre><code class="language-julia hljs">filled_q = fill(u&quot;m/s&quot;, 10)
println(&quot;Filled QuantityArray: &quot;, filled_q)</code></pre><p><code>fill</code> works for 0 dimensional <code>QuantityArray</code>s as well:</p><pre><code class="language-julia hljs">empty_q = fill(u&quot;m/s&quot;, ())
println(&quot;0 dimensional QuantityArray: &quot;, empty_q)</code></pre><h3 id="Similar"><a class="docs-heading-anchor" href="#Similar">Similar</a><a id="Similar-1"></a><a class="docs-heading-anchor-permalink" href="#Similar" title="Permalink"></a></h3><p>Likewise, we can create a <code>QuantityArray</code> with the same properties as another <code>QuantityArray</code>:</p><pre><code class="language-julia hljs">qa = QuantityArray(rand(3, 4), u&quot;m&quot;)

new_qa = similar(qa)

println(&quot;Similar qa: &quot;, new_qa)</code></pre><h3 id="Promotion"><a class="docs-heading-anchor" href="#Promotion">Promotion</a><a id="Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion" title="Permalink"></a></h3><p>Promotion rules are defined for <code>QuantityArray</code>s:</p><pre><code class="language-julia hljs">qarr1 = QuantityArray(randn(32), convert(Dimensions{Rational{Int32}}, dimension(u&quot;km/s&quot;)))
qarr2 = QuantityArray(randn(Float16, 32), convert(Dimensions{Rational{Int64}}, dimension(u&quot;km/s&quot;)))</code></pre><p>See what type they promote to:</p><pre><code class="language-julia hljs">println(&quot;Promoted type: &quot;, typeof(promote(qarr1, qarr2)))</code></pre><h3 id="Array-Concatenation"><a class="docs-heading-anchor" href="#Array-Concatenation">Array Concatenation</a><a id="Array-Concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Concatenation" title="Permalink"></a></h3><p>Likewise, we can take advantage of array concatenation, which will ensure we have the same dimensions:</p><pre><code class="language-julia hljs">qarr1 = QuantityArray(randn(3) .* u&quot;km/s&quot;)
qarr2 = QuantityArray(randn(3) .* u&quot;km/s&quot;)</code></pre><p>Concatenate them:</p><pre><code class="language-julia hljs">concat_qarr = hcat(qarr1, qarr2)
println(&quot;Concatenated QuantityArray: &quot;, concat_qarr)</code></pre><h3 id="Symbolic-Units"><a class="docs-heading-anchor" href="#Symbolic-Units">Symbolic Units</a><a id="Symbolic-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Units" title="Permalink"></a></h3><p>We can use arbitrary <code>AbstractQuantity</code> and <code>AbstractDimensions</code> in a <code>QuantityArray</code>, including <code>SymbolicDimensions</code>:</p><pre><code class="language-julia hljs">z_ar = randn(32)
z = QuantityArray(z_ar, us&quot;Constants.M_sun * km/s&quot;)</code></pre><p>Expand to standard units:</p><pre><code class="language-julia hljs">z_expanded = uexpand(z)
println(&quot;Expanded z: &quot;, z_expanded)</code></pre><h3 id="GenericQuantity-Construction"><a class="docs-heading-anchor" href="#GenericQuantity-Construction">GenericQuantity Construction</a><a id="GenericQuantity-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#GenericQuantity-Construction" title="Permalink"></a></h3><p>In addition to <code>Quantity</code>, we can also use <code>GenericQuantity</code>:</p><pre><code class="language-julia hljs">x = GenericQuantity(1.5)
y = GenericQuantity(0.2u&quot;km&quot;)
println(y)</code></pre><p>This <code>GenericQuantity</code> is subtyped to <code>Any</code>, rather than <code>Number</code>, and thus can also store custom non-scalar types.</p><p>For example, we can work with <code>Coords</code>, and wrap it in a single <code>GenericQuantity</code> type:</p><pre><code class="language-julia hljs">struct Coords
    x::Float64
    y::Float64
end

# Define arithmetic operations on Coords
Base.:+(a::Coords, b::Coords) = Coords(a.x + b.x, a.y + b.y)
Base.:-(a::Coords, b::Coords) = Coords(a.x - b.x, a.y - b.y)
Base.:*(a::Coords, b::Number) = Coords(a.x * b, a.y * b)
Base.:*(a::Number, b::Coords) = Coords(a * b.x, a * b.y)
Base.:/(a::Coords, b::Number) = Coords(a.x / b, a.y / b)</code></pre><p>We can then build a <code>GenericQuantity</code> out of this:</p><pre><code class="language-julia hljs">coord1 = GenericQuantity(Coords(0.3, 0.9), length=1)
coord2 = GenericQuantity(Coords(0.2, -0.1), length=1)</code></pre><p>and perform operations on these:</p><pre><code class="language-julia hljs">coord1 + coord2 |&gt; us&quot;cm&quot;
# (Coords(50.0, 80.0)) cm</code></pre><p>The nice part about this is it only stores a single Dimensions (or <code>SymbolicDimensions</code>) for the entire struct!</p><h3 id="GenericQuantity-and-Quantity-Promotion"><a class="docs-heading-anchor" href="#GenericQuantity-and-Quantity-Promotion">GenericQuantity and Quantity Promotion</a><a id="GenericQuantity-and-Quantity-Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#GenericQuantity-and-Quantity-Promotion" title="Permalink"></a></h3><p>When we combine a <code>GenericQuantity</code> and a <code>Quantity</code>, the result is another <code>GenericQuantity</code>:</p><pre><code class="language-julia hljs">x = GenericQuantity(1.5f0)
y = Quantity(1.5, length=1)
println(&quot;Promoted type of x and y: &quot;, typeof(x * y))</code></pre><h3 id="Custom-Dimensions"><a class="docs-heading-anchor" href="#Custom-Dimensions">Custom Dimensions</a><a id="Custom-Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Dimensions" title="Permalink"></a></h3><p>We can create custom dimensions by subtyping to <code>AbstractDimensions</code>:</p><pre><code class="language-julia hljs">struct MyDimensions{R} &lt;: AbstractDimensions{R}
    cookie::R
    milk::R
end</code></pre><p>Many constructors and functions are defined on <code>AbstractDimensions</code>, so this can be used out-of-the-box. We can then use this in a <code>Quantity</code>, and all operations will work as expected:</p><pre><code class="language-julia hljs">x = Quantity(1.5, MyDimensions(cookie=1, milk=-1))
y = Quantity(2.0, MyDimensions(milk=1))

x * y</code></pre><p>which gives us <code>3.0 cookie</code> computed from a rate of <code>1.5 cookie milk⁻¹</code> multiplied by <code>2.0 milk</code>. Likewise, we can use these in a <code>QuantityArray</code>:</p><pre><code class="language-julia hljs">x_qa = QuantityArray(randn(32), MyDimensions(cookie=1, milk=-1))

x_qa .^ 2</code></pre><h3 id="Custom-Quantities"><a class="docs-heading-anchor" href="#Custom-Quantities">Custom Quantities</a><a id="Custom-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Quantities" title="Permalink"></a></h3><p>We can also create custom dimensions by subtyping to either <code>AbstractQuantity</code> (for <code>&lt;:Number</code>) or <code>AbstractGenericQuantity</code> (for <code>&lt;:Any</code>):</p><pre><code class="language-julia hljs">struct MyQuantity{T,D} &lt;: AbstractQuantity{T,D}
    value::T
    dimensions::D
end</code></pre><p>Since <code>AbstractQuantity &lt;: Number</code>, this will also be a number. Keep in mind that you must call these fields <code>value</code> and <code>dimensions</code> for <code>ustrip(...)</code> and <code>dimension(...)</code> to work. Otherwise, simply redefine those.</p><p>We can use this custom quantity just like we would use <code>Quantity</code>:</p><pre><code class="language-julia hljs">q1 = MyQuantity(1.2, Dimensions(length=-2))
# prints as `1.2 m⁻²`

q2 = MyQuantity(1.5, MyDimensions(cookie=1))
# prints as `1.5 cookie`</code></pre><p>Including mathematical operations:</p><pre><code class="language-julia hljs">q2 ^ 2
# `2.25 cookie²`</code></pre><p>The main reason you would use a custom quantity is if you want to change built-in behavior, or maybe have special methods for different types of quantities.</p><p>Note that you can declare a method on <code>AbstractQuantity</code>, or <code>AbstractGenericQuantity</code> to allow their respective inputs.</p><p><strong>Note</strong>: In general, you should probably specialize on <code>UnionAbstractQuantity</code> which is the union of these two abstract quantities, <em>as well as any other future abstract quantity types</em>, such as the planned <code>AbstractRealQuantity</code>.</p><pre><code class="language-julia hljs">function my_func(x::UnionAbstractQuantity{T,D}) where {T,D}
    # value has type T and dimensions has type D
    return x / ustrip(x)
end</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Attribution: <a href="https://ocw.mit.edu/courses/5-111sc-principles-of-chemical-science-fall-2014/resources/mit5_111f14_lec04soln/">MIT OCW</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 9 November 2024 23:28">Saturday 9 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
